{"version":3,"sources":["intersectionBy.js"],"names":[],"mappings":"AAAA,IAAI,WAAW,QAAQ,aAAR,CAAf;IACI,mBAAmB,QAAQ,qBAAR,CADvB;IAEI,eAAe,QAAQ,iBAAR,CAFnB;IAGI,WAAW,QAAQ,aAAR,CAHf;IAII,sBAAsB,QAAQ,wBAAR,CAJ1B;IAKI,OAAO,QAAQ,QAAR,CALX;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,IAAI,iBAAiB,SAAS,UAAS,MAAT,EAAiB;AAC7C,MAAI,WAAW,KAAK,MAAL,CAAf;MACI,SAAS,SAAS,MAAT,EAAiB,mBAAjB,CADb;;AAGA,MAAI,aAAa,KAAK,MAAL,CAAjB,EAA+B;AAC7B,eAAW,SAAX;AACD,GAFD,MAEO;AACL,WAAO,GAAP;AACD;AACD,SAAQ,OAAO,MAAP,IAAiB,OAAO,CAAP,MAAc,OAAO,CAAP,CAAhC,GACH,iBAAiB,MAAjB,EAAyB,aAAa,QAAb,EAAuB,CAAvB,CAAzB,CADG,GAEH,EAFJ;AAGD,CAZoB,CAArB;;AAcA,OAAO,OAAP,GAAiB,cAAjB","file":"intersectionBy-compiled.js","sourcesContent":["var arrayMap = require('./_arrayMap'),\n    baseIntersection = require('./_baseIntersection'),\n    baseIteratee = require('./_baseIteratee'),\n    baseRest = require('./_baseRest'),\n    castArrayLikeObject = require('./_castArrayLikeObject'),\n    last = require('./last');\n\n/**\n * This method is like `_.intersection` except that it accepts `iteratee`\n * which is invoked for each element of each `arrays` to generate the criterion\n * by which they're compared. The order and references of result values are\n * determined by the first array. The iteratee is invoked with one argument:\n * (value).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n * // => [2.1]\n *\n * // The `_.property` iteratee shorthand.\n * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n * // => [{ 'x': 1 }]\n */\nvar intersectionBy = baseRest(function(arrays) {\n  var iteratee = last(arrays),\n      mapped = arrayMap(arrays, castArrayLikeObject);\n\n  if (iteratee === last(mapped)) {\n    iteratee = undefined;\n  } else {\n    mapped.pop();\n  }\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped, baseIteratee(iteratee, 2))\n    : [];\n});\n\nmodule.exports = intersectionBy;\n"]}