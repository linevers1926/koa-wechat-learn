{"version":3,"sources":["streamify.js"],"names":[],"mappings":"AAAA,IAAI,QAAQ,QAAQ,YAAR,CAAZ;;;AAGA,OAAO,OAAP,GAAiB;AACf,YAAU,YADK;AAEf,YAAU;AAFK,CAAjB;;;;;;;;;AAYA,SAAS,YAAT,CAAsB,QAAtB,EACA;AACE,MAAI,SAAS,IAAb;;AAEA,SAAO,UAAS,IAAT,EAAe,GAAf,EAAoB,EAApB,EACP;AACE,QAAI,OAAJ;QACI,YAAY,MAAM,qBAAqB,IAArB,CAA0B,MAA1B,EAAkC,EAAlC,EAAsC,GAAtC,CAAN,CADhB;;AAIA,WAAO,IAAP,CAAY,GAAZ,IAAmB,SAAnB;;;AAGA,QAAI,SAAS,MAAT,IAAmB,CAAvB,EACA;AACE,gBAAU,SAAS,IAAT,EAAe,SAAf,CAAV;AACD;;AAHD,SAMA;AACE,kBAAU,SAAS,IAAT,EAAe,GAAf,EAAoB,SAApB,CAAV;AACD;;AAED,WAAO,OAAP;AACD,GApBD;AAqBD;;;;;;;;;;;AAWD,SAAS,YAAT,CAAsB,QAAtB,EACA;AACE,MAAI,SAAS,IAAb;;AAEA,MAAI,UAAU,UAAS,KAAT,EAAgB,MAAhB,EACd;AACE,WAAO,SAAS,IAAT,CAAc,MAAd,EAAsB,KAAtB,EAA6B,MAA7B,EAAqC,QAArC,CAAP;AACD,GAHD;;AAKA,SAAO,OAAP;AACD;;;;;;;;;;;;AAYD,SAAS,oBAAT,CAA8B,QAA9B,EAAwC,GAAxC,EACA;AACE,MAAI,SAAS,IAAb;;AAEA,SAAO,UAAS,KAAT,EAAgB,MAAhB,EACP;;AAEE,QAAI,EAAE,OAAO,OAAO,IAAhB,CAAJ,EACA;AACE,eAAS,KAAT,EAAgB,MAAhB;AACA;AACD;;;AAGD,WAAO,OAAO,IAAP,CAAY,GAAZ,CAAP;;AAEA,WAAO,SAAS,IAAT,CAAc,MAAd,EAAsB,KAAtB,EAA6B,EAAC,KAAK,GAAN,EAAW,OAAO,MAAlB,EAA7B,EAAwD,QAAxD,CAAP;AACD,GAbD;AAcD;;;;;;;;;;AAUD,SAAS,QAAT,CAAkB,KAAlB,EAAyB,MAAzB,EAAiC,QAAjC,EACA;AACE,MAAI,SAAS,CAAC,KAAK,KAAnB,EACA;AACE,SAAK,KAAL,GAAa,KAAb;AACA,SAAK,KAAL;AACA,SAAK,IAAL,CAAU,OAAV,EAAmB,KAAnB;;AAEA,aAAS,KAAT,EAAgB,UAAU,OAAO,KAAjC;AACA;AACD;;;AAGD,OAAK,IAAL,CAAU,MAAV;;;;AAIA,WAAS,KAAT,EAAgB,UAAU,OAAO,KAAjC;AACD;;;;;;;;;;AAUD,SAAS,QAAT,CAAkB,KAAlB,EAAyB,MAAzB,EAAiC,QAAjC,EACA;;;AAGE,MAAI,CAAC,KAAL,EACA;AACE,SAAK,IAAL,CAAU,IAAV;AACD;;;AAGD,WAAS,KAAT,EAAgB,MAAhB;AACD","file":"streamify-compiled.js","sourcesContent":["var async = require('./async.js');\n\n// API\nmodule.exports = {\n  iterator: wrapIterator,\n  callback: wrapCallback\n};\n\n/**\n * Wraps iterators with long signature\n *\n * @this    ReadableAsyncKit#\n * @param   {function} iterator - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapIterator(iterator)\n{\n  var stream = this;\n\n  return function(item, key, cb)\n  {\n    var aborter\n      , wrappedCb = async(wrapIteratorCallback.call(stream, cb, key))\n      ;\n\n    stream.jobs[key] = wrappedCb;\n\n    // it's either shortcut (item, cb)\n    if (iterator.length == 2)\n    {\n      aborter = iterator(item, wrappedCb);\n    }\n    // or long format (item, key, cb)\n    else\n    {\n      aborter = iterator(item, key, wrappedCb);\n    }\n\n    return aborter;\n  };\n}\n\n/**\n * Wraps provided callback function\n * allowing to execute snitch function before\n * real callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - function to wrap\n * @returns {function} - wrapped function\n */\nfunction wrapCallback(callback)\n{\n  var stream = this;\n\n  var wrapped = function(error, result)\n  {\n    return finisher.call(stream, error, result, callback);\n  };\n\n  return wrapped;\n}\n\n/**\n * Wraps provided iterator callback function\n * makes sure snitch only called once,\n * but passes secondary calls to the original callback\n *\n * @this    ReadableAsyncKit#\n * @param   {function} callback - callback to wrap\n * @param   {number|string} key - iteration key\n * @returns {function} wrapped callback\n */\nfunction wrapIteratorCallback(callback, key)\n{\n  var stream = this;\n\n  return function(error, output)\n  {\n    // don't repeat yourself\n    if (!(key in stream.jobs))\n    {\n      callback(error, output);\n      return;\n    }\n\n    // clean up jobs\n    delete stream.jobs[key];\n\n    return streamer.call(stream, error, {key: key, value: output}, callback);\n  };\n}\n\n/**\n * Stream wrapper for iterator callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects iterator results\n */\nfunction streamer(error, output, callback)\n{\n  if (error && !this.error)\n  {\n    this.error = error;\n    this.pause();\n    this.emit('error', error);\n    // send back value only, as expected\n    callback(error, output && output.value);\n    return;\n  }\n\n  // stream stuff\n  this.push(output);\n\n  // back to original track\n  // send back value only, as expected\n  callback(error, output && output.value);\n}\n\n/**\n * Stream wrapper for finishing callback\n *\n * @this  ReadableAsyncKit#\n * @param {mixed} error - error response\n * @param {mixed} output - iterator output\n * @param {function} callback - callback that expects final results\n */\nfunction finisher(error, output, callback)\n{\n  // signal end of the stream\n  // only for successfully finished streams\n  if (!error)\n  {\n    this.push(null);\n  }\n\n  // back to original track\n  callback(error, output);\n}\n"]}