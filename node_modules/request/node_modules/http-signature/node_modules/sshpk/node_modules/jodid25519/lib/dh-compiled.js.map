{"version":3,"sources":["dh.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,IAAI,OAAO,QAAQ,QAAR,CAAX;AACA,IAAI,QAAQ,QAAQ,SAAR,CAAZ;AACA,IAAI,WAAW,QAAQ,YAAR,CAAf;;;;;;;;;AAUI,IAAI,KAAK,EAAT;;AAGA,SAAS,SAAT,CAAmB,MAAnB,EAA2B;AACvB,QAAI,IAAI,IAAI,WAAJ,CAAgB,MAAhB,CAAR;AACA,WAAQ,IAAI,MAAJ,CAAW,IAAI,UAAJ,CAAe,EAAE,MAAjB,CAAX,CAAR;AACH;;AAED,SAAS,WAAT,CAAqB,MAArB,EAA6B;AACzB,QAAI,OAAO,QAAP,CAAgB,MAAhB,CAAJ,EAA6B;AACzB,YAAI,IAAI,IAAI,UAAJ,CAAe,MAAf,CAAR;AACA,eAAQ,IAAI,WAAJ,CAAgB,EAAE,MAAlB,CAAR;AACH;;AAED,QAAI,SAAS,IAAI,KAAJ,CAAU,EAAV,CAAb;AACA,SAAK,IAAI,IAAI,CAAR,EAAW,IAAI,CAApB,EAAuB,IAAI,OAAO,MAAlC,EAA0C,KAAK,CAA/C,EAAkD;AAC9C,eAAO,CAAP,IAAa,OAAO,UAAP,CAAkB,IAAI,CAAtB,KAA4B,CAA7B,GAAkC,OAAO,UAAP,CAAkB,CAAlB,CAA9C;AACA;AACH;AACD,WAAO,MAAP;AACH;;;;;;;;;;;;;;;;;;;;;;;AAwBD,GAAG,UAAH,GAAgB,UAAS,gBAAT,EAA2B,eAA3B,EAA4C;AACxD,QAAI,eAAJ,EAAqB;AACjB,eAAO,UAAU,SAAS,UAAT,CAAoB,YAAY,gBAAZ,CAApB,EACoB,YAAY,eAAZ,CADpB,CAAV,CAAP;AAEH,KAHD,MAGO;AACH,eAAO,UAAU,SAAS,UAAT,CAAoB,YAAY,gBAAZ,CAApB,CAAV,CAAP;AACH;AACJ,CAPD;;;;;;;;;;;;;;;;AAuBA,GAAG,SAAH,GAAe,UAAS,UAAT,EAAqB;AAChC,WAAO,UAAU,SAAS,UAAT,CAAoB,YAAY,UAAZ,CAApB,CAAV,CAAP;AACH,CAFD;;;;;;;;;AAYA,GAAG,WAAH,GAAiB,YAAW;AACxB,WAAO,KAAK,WAAL,CAAiB,IAAjB,CAAP;AACH,CAFD;;AAIJ,OAAO,OAAP,GAAiB,EAAjB","file":"dh-compiled.js","sourcesContent":["\"use strict\";\n/**\n * @fileOverview\n * EC Diffie-Hellman operations on Curve25519.\n */\n\n/*\n * Copyright (c) 2014 Mega Limited\n * under the MIT License.\n *\n * Authors: Guy K. Kloss\n *\n * You should have received a copy of the license along with this program.\n */\n\nvar core = require('./core');\nvar utils = require('./utils');\nvar curve255 = require('./curve255');\n\n\n    /**\n     * @exports jodid25519/dh\n     * EC Diffie-Hellman operations on Curve25519.\n     *\n     * @description\n     * EC Diffie-Hellman operations on Curve25519.\n     */\n    var ns = {};\n\n\n    function _toString(vector) {\n        var u = new Uint16Array(vector);\n        return (new Buffer(new Uint8Array(u.buffer)));\n    }\n\n    function _fromString(vector) {\n        if (Buffer.isBuffer(vector)) {\n            var u = new Uint8Array(vector);\n            return (new Uint16Array(u.buffer));\n        }\n\n        var result = new Array(16);\n        for (var i = 0, l = 0; i < vector.length; i += 2) {\n            result[l] = (vector.charCodeAt(i + 1) << 8) | vector.charCodeAt(i);\n            l++;\n        }\n        return result;\n    }\n\n\n    /**\n     * Computes a key through scalar multiplication of a point on the curve 25519.\n     *\n     * This function is used for the DH key-exchange protocol. It computes a\n     * key based on a secret key with a public component (opponent's public key\n     * or curve base point if not given) by using scalar multiplication.\n     *\n     * Before multiplication, some bit operations are applied to the\n     * private key to ensure it is a valid Curve25519 secret key.\n     * It is the user's responsibility to make sure that the private\n     * key is a uniformly random, secret value.\n     *\n     * @function\n     * @param privateComponent {string}\n     *     Private point as byte string on the curve.\n     * @param publicComponent {string}\n     *     Public point as byte string on the curve. If not given, the curve's\n     *     base point is used.\n     * @returns {string}\n     *     Key point as byte string resulting from scalar product.\n     */\n    ns.computeKey = function(privateComponent, publicComponent) {\n        if (publicComponent) {\n            return _toString(curve255.curve25519(_fromString(privateComponent),\n                                                 _fromString(publicComponent)));\n        } else {\n            return _toString(curve255.curve25519(_fromString(privateComponent)));\n        }\n    };\n\n    /**\n     * Computes the public key to a private key on the curve 25519.\n     *\n     * Before multiplication, some bit operations are applied to the\n     * private key to ensure it is a valid Curve25519 secret key.\n     * It is the user's responsibility to make sure that the private\n     * key is a uniformly random, secret value.\n     *\n     * @function\n     * @param privateKey {string}\n     *     Private point as byte string on the curve.\n     * @returns {string}\n     *     Public key point as byte string resulting from scalar product.\n     */\n    ns.publicKey = function(privateKey) {\n        return _toString(curve255.curve25519(_fromString(privateKey)));\n    };\n\n\n    /**\n     * Generates a new random private key of 32 bytes length (256 bit).\n     *\n     * @function\n     * @returns {string}\n     *     Byte string containing a new random private key seed.\n     */\n    ns.generateKey = function() {\n        return core.generateKey(true);\n    };\n\nmodule.exports = ns;\n"]}